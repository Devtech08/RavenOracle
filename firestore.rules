rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * CORE SECURITY PHILOSOPHY:
     * This ruleset implements a highly centralized administrative control model for the Raven Oracle portal.
     * 1. Admin Supremacy: Administrative privileges are determined by the existence of a record in the 
     *    dedicated '/roles_admin' collection (Database-Based Access Control).
     * 2. Strict User Oversight: While users own their profiles, only administrators can list all members,
     *    block access, or remove users entirely.
     * 3. Identity & Reputation: Every user must be associated with a unique 'callsign' and 'id'. 
     *    Access is strictly gated via 'isBlocked' flags denormalized on user documents.
     * 4. Secure Provisioning: New user access is managed through 'accessKeys' created by admins, 
     *    preventing unauthorized self-registration.
     * 5. Structural Segregation: System configurations (Gateway) and sensitive logs (MessageLogs) 
     *    are segregated from standard user data to ensure clean, role-based access boundaries.
     */

    // --- HELPER FUNCTIONS ---

    function isSignedIn() {
      return request.auth != null;
    }

    // Checks if the current user is an admin by looking at the roles_admin collection
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    // Checks if the user is the owner of the document
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    // Checks if the user exists and is not currently blocked by an admin
    function isNotBlocked() {
      return isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.isBlocked == false;
    }

    // Combines ownership and existence for safe updates/deletes
    function isExistingOwner(userId) {
      return resource != null && isOwner(userId);
    }

    // --- COLLECTION RULES ---

    /**
     * @description Rules for the 'User' collection. Admins can manage all, users manage self.
     * @path /users/{userId}
     * @allow get: if isSignedIn() (for profiles); list: if isAdmin() (per requirement: only admin can view all).
     * @deny list: if !isAdmin() (prevents user listing by non-admins).
     * @principle Ownership for personal data, Admin-only for member discovery and moderation.
     */
    match /users/{userId} {
      allow get: if isSignedIn();
      allow list: if isAdmin();
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if (isExistingOwner(userId) || isAdmin()) && request.resource.data.id == resource.data.id;
      allow delete: if isAdmin();
    }

    /**
     * @description Secure configuration for the site's entry point.
     * @path /gateway/{gatewayId}
     * @allow get, list: if isSignedIn(); create, update, delete: if isAdmin().
     * @deny write: if !isAdmin() (only admin can reset/update gateway address).
     * @principle Restricted write access for core system configuration.
     */
    match /gateway/{gatewayId} {
      allow get, list: if isSignedIn();
      allow create, update, delete: if isAdmin();
    }

    /**
     * @description Management of invitation/access keys generated by admins.
     * @path /accessKeys/{accessKeyId}
     * @allow get: if isSignedIn(); list: if isAdmin(); create: if isAdmin(); update: if isSignedIn().
     * @deny create: if !isAdmin() (users cannot generate their own invitation keys).
     * @principle Admin-driven user provisioning and invitation management.
     */
    match /accessKeys/{accessKeyId} {
      allow get: if isSignedIn();
      allow list, create: if isAdmin();
      allow update: if isSignedIn() && (isAdmin() || request.resource.data.userId == request.auth.uid);
      allow delete: if isAdmin();
    }

    /**
     * @description System message logs. Admins can audit all; users can only append logs.
     * @path /messageLogs/{messageLogId}
     * @allow create: if isSignedIn() && isNotBlocked(); get, list: if isAdmin().
     * @deny read: if !isAdmin() (non-admins cannot audit message history).
     * @principle Log collection for auditing with restricted read access.
     */
    match /messageLogs/{messageLogId} {
      allow get, list: if isAdmin();
      allow create: if isSignedIn() && isNotBlocked() && request.resource.data.senderId == request.auth.uid;
      allow update, delete: if isAdmin();
    }

    /**
     * @description Existence-based admin role collection. Source of truth for isAdmin().
     * @path /roles_admin/{userId}
     * @allow get: if isSignedIn(); write, list: if isAdmin().
     * @deny write: if !isAdmin() (prevents privilege escalation).
     * @principle Database-Based Access Control (DBAC) for administrative roles.
     */
    match /roles_admin/{userId} {
      allow get: if isSignedIn();
      allow list, create, update, delete: if isAdmin();
    }

  }
}